<!DOCTYPE html>
<html lang="en">
   <meta charset="utf-8">
   <head>
      <title>XML Shader (1.0) Viewer</title>

      <style type="text/css">
         body {
            background: #999999;
            font-family: sans-serif;
            margin: 15px;
         }

         #text, #title, #content {
            border: 1px solid #bbbbbb;
            padding: 15px;
            margin: 5px;
            background: #eeeeee;
         }

         hr {
            color: black;
         }

         #test_canvas {
            background: #000000;
         }

         .aligned {
            font-weight: bold;
            margin-right: 5px;
         }

         .output {
            position: relative;
            left: 10px;
         }

         textarea {
            font-family: monospace;
         }
      </style>
   </head>
   
   <body onload="webGLStart();">

      <div id="title">
         <h1>XML shader viewer</h1>
         <hr/>
         <h3 style="text-align: right">by Themaister</h3>
      </div>

      <div id="text">
         <p>Here's a WebGL application to test your shaders against various images from your harddrive.</p>
         <p>Written in pure HTML5/JavaScript, and can be run locally, just download the page source/script.
         It does not use the various fancy WebGL engines, so there might be something interesting inside ...</p>

         <p>Shaders need to conform to the XML shader specification (as supported in 
         <a href="http://byuu.org/bsnes/">bSNES</a>,
         <a href="https://github.com/Themaister/SSNES">SSNES</a> and
         <a href="http://snes9x.com">SNES9x-Win32</a>).
         A draft of this spec can be found
         <a href="https://gitorious.org/bsnes/pages/XmlShaderFormat">here.</a>
         Note that only the 1.0 subset is supported. Some example shaders can be found
         <a href="https://gitorious.org/bsnes/bsnes/trees/patches/snesshader">here.</a></p>
         <p>Note that it is not limited to emulators, but it's certainly geared for 2D images.</p>

         <p>Do note that the XML shader is converted internally to be supported by OpenGL ES 2.0.
         The XML shader spec bases itself on pre-OpenGL 3.x.
         Some fixed-function components are redefined to properly use varying/attribute components.</p>
      </div>

      <div id="content">
         <div id="scale">
            <h3>Global</h3>
            <p><span class="aligned">Total scale:</span>
            <input type="button" onclick="do_resize(0.25);" value="0.25x"/>
            <input type="button" onclick="do_resize(0.5);" value="0.5x"/>
            <input type="button" onclick="do_resize(1);" value="1x"/>
            <input type="button" onclick="do_resize(2);" value="2x"/>
            <input type="button" onclick="do_resize(3);" value="3x"/>
            <input type="button" onclick="do_resize(4);" value="4x"/>
            <input type="button" onclick="do_resize(5);" value="5x"/>
            <output class="output" id="total_scale_output">1x</output></p>

            <p><span class="aligned">Image:</span>
            <input type="file" id="image_file" name="files[]"/>
            <input type="button" onclick="reset_image();" value="Reset"/>
            <output class="output" id="image_output">None</output></p>
         </div>

         <hr/>

         <div id="shader_1">
            <h3>Pass #1</h3>

            <p><span class="aligned">Shader:</span>
            <input type="file" id="shader_file" name="files[]"/>
            <input type="button" onclick="reset_shader();" value="Reset"/>
            <output class="output" id="shader1_output">Default</p>

            <p><span class="aligned">Filter:</span>
            <input type="button" onclick="do_filter1(false)" value="Point"/>
            <input type="button" onclick="do_filter1(true)" value="Linear"/>
            <output class="output" id="filter1_output">Point</p>
         </div>

         <hr/>

         <div id="shader_2">
            <h3>Pass #2 (optional)</h3>
            <p><span class="aligned">FBO scale:</span>
            <input type="button" onclick="do_fbo_scale(0);" value="Off"/>
            <input type="button" onclick="do_fbo_scale(1);" value="1x"/>
            <input type="button" onclick="do_fbo_scale(2);" value="2x"/>
            <input type="button" onclick="do_fbo_scale(3);" value="3x"/>
            <input type="button" onclick="do_fbo_scale(4);" value="4x"/>
            <output class="output" id="fbo_scale_output">Off</output></p>

            <p><span class="aligned">Shader:</span>
            <input type="file" id="shader_file2" name="files[]"/>
            <input type="button" onclick="reset_shader2();" value="Reset"/>
            <output class="output" id="shader2_output">Default</output></p>

            <p><span class="aligned">Filter:</span>
            <input type="button" onclick="do_filter2(false)" value="Point"/>
            <input type="button" onclick="do_filter2(true)" value="Linear"/>
            <output class="output" id="filter2_output">Point</p>
         </div>

         <hr/>
         <h3>Output</h3>
         <canvas id="test_canvas" style="border: none" width="256" height="224"></canvas><br/>
         <p style="font-size: 75%">Hint: You can save the final result just as you would save an image!</p>
         <hr/>

         <h3>Logging</h3>
         <h4>Error console</h4>
         <textarea id="error_console" readonly cols="50" rows="10"></textarea>
         <hr/>
         <h4>Shader #1</h4>
         <output id="text_output"></output><br/>
         <hr/>
         <h4>Shader #2</h4>
         <output id="text_output2"></output><br/>
      </div>
   </body>

   <script id="vertex_shader" type="x-shader/x-vertex">
      attribute vec2 rubyVertex;
      attribute vec2 rubyTexCoord;
      varying vec4 rubyTexCoord_[8];
      void main()
      {
         gl_Position = vec4(rubyVertex, 0.0, 1.0);
         rubyTexCoord_[0] = vec4(rubyTexCoord, 0.0, 1.0);
      }
   </script>

   <script id="fragment_shader" type="x-shader/x-fragment">
      #ifdef GL_ES
      precision highp float;
      #endif

      uniform sampler2D rubyTexture;
      varying vec4 rubyTexCoord_[8];

      void main()
      {
         gl_FragColor = texture2D(rubyTexture, rubyTexCoord_[0].xy);
      }
   </script>
   <script type="text/javascript" src="xmlshader.js"></script>
</html>
